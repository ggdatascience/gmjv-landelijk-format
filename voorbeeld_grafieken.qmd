---
title: ""
author: ""
format:
  html:
    page-layout: full
    css: custom.css
    toc: TRUE
    toc-location: left
    embed-resources: true
  pdf: 
    classoption: landscape
    toc: TRUE
    tol: TRUE
params:
  gemeentecode: 2 
editor: visual
format-links: false
crossref:
  fig-title: Grafiek
  fig-prefix: Grafiek
---

```{r, echo=F, message=F, warning=F}
# Het script maakt gebruik van een aantal packages
# Deze moeten bij de eerste keer lokaal worden geinstalleerd
# Hieronder worden de benodige packages geladen
library(gt)
library(dplyr)
library(ggplot2)
library(tidyr)
library(haven)
library(stringr) # Voor str_replace
library(labelled) # Package om te werken met datalabels, o.a. voor to_character()
library(survey) # Package om te werken met gewogen gemiddelds incl. betrouwbaarheidsintervallen
library(glue) #om strings aangenaam aan elkaar te plakken
library(plotly)

options(dplyr.summarise.inform = FALSE)
source("hulpfuncties.R")

#TODO instelbare variabelen overzichtelijk maken

#Standaardwaarden in te stellen door gebruiker:
# Standaard kleuren
default_kleuren_grafiek <- c("#012C17","#76B82A","#007E48")
default_kleuren_responstabel <- c("header" = "#012C17",
                                  "kleur_1" = "#007E48",
                                  "kleur_2" = "#76B82A",
                                  "kleur_tekst" = "#FFFFFF"
                                  )

# Standaard minima voor groep & cel
default_Nvar = 100 # Minimum aantal invullers per vraag.
default_Ncel = 10 # Minimum aantal invullers oper antwoordoptie.

# Standaard regio
# Pas onderstaande naam en code aan naar de naam en code van je eigen regio.

#TODO regio naar params
regionaam <- 'GGD Limburg-Noord'
regiocode <- 23

#SPSS data inlezen
# Regionaal bestand
#file_path_regio = "nep testdata GMJV - Regionaal trendbestand 2022-2024.sav"
# Landelijk bestand
file_path_land = "nep testdata GMJV - Regionaal trendbestand 2022-2024.sav"

#Lees SPSS bestand & converteer 'user-missing' naar missing in R (NA)
#monitor_df = haven::read_spss(file_path_regio, user_na =T) %>%
 # labelled::user_na_to_na()

#1 landelijk bestand inlezen
monitor_df = haven::read_spss(file_path_land,user_na =T) %>%
  labelled::user_na_to_na()

#TODO verwijderen bij echte data. tijdelijk varlabel voor jaarvariabele
var_label(monitor_df$AGOJB401) <- "Jaar"

#Maak survey designs
# Regionaal 2022 en 2024
#TODO bij echte data standaardisatiefactor en stratum aanpassen per niveau

# Het landelijk en regionaal design hebben dezelfde weegfactoren. Daarom maken we een Een landelijk design obv landelijke dataset en een regionaal design obv een subset van het landelijk design.
# Landelijk 2022 en 2024
design_land <- survey_design_maken(
                         strata = 'Stratum',
                         gewichten = 'Standaardisatiefactor',
                         data = monitor_df)


#design regio is een subset van design land met ggdregio overgehouden.
#subset data
design_regio <- subset(design_land, GGDregio == regiocode)


#Het gemeentelijk design heeft andere weegfactoren. De gehele dataset waar het gem. design over geld is de GGDregio. Daarom maken we eerst een regionaal design o.b.v. de hele ggdregio en subsetten we daarna het gemeentedesign.
design_gem_regio <- survey_design_maken(
                          strata = 'Stratum', #hier komen andere parameters
                          gewichten = 'Standaardisatiefactor',  #hier ook
                          data = monitor_df %>% 
                            filter(GGDregio == regiocode))

design_gem <- subset(design_gem_regio, Gemeentecode == params$gemeentecode)

rm(design_gem_regio) #temp regiodesign voor gemdesign verwijderen niet meer nodig


#Er is niet goed aangegeven wat missing is in SPSS.
#tijdelijke functie om 9 Onbekend te verwijderen & naar NA te zetten

for(var in names(monitor_df)){
  
  monitor_df <- monitor_df %>% verwijder_9_onbekend(var)

}

#TODO Tijdelijke filter op alleen gemeente in parameter
# monitor_df_regio <- monitor_df
# monitor_df <- monitor_df %>%
#   filter(Gemeentecode == params$gemeentecode)

#Maak survey design gemeente
# Gemeente 2022 en 2024
# design_gem <- survey_design_maken(
#                           strata = 'Stratum', 
#                           gewichten = 'Standaardisatiefactor', 
#                           data = monitor_df)

# ALTERNATIEVE METHODE VAN INLADEN: regionale data invoegen in landelijk
# Landelijk bestand inladen
# df <- haven::read_spss(file.choose(), user_na =T) %>%
#   labelled::user_na_to_na()
# 
# # Regionaal bestand inladen
# df_regio <- haven::read_spss(file.choose(), user_na =T) %>%
#   labelled::user_na_to_na()
# 
# # Check of aantallen gelijk zijn.
# # NB. Alleen deelnemers met landelijke weegfactor zitten in landelijk bestand.
# if (sum(df_regio$Standaardisatiefactor != 0) != nrow(df %>% filter(GGDregio == regiocode))) {
#   print("Aantal deelnemers in regio is niet hetzelfde in beide bestanden, check data.")
# }
# 
#
# TODO zorgen dat hier ook nog op jaar gefilterd wordt!
# # Filter regio uit landelijk databestand
# df <- df %>%
#   filter(GGDregio != regiocode)
# 
# # Voeg regiobestand toe aan landelijk bestand
# df <- df %>%
#   full_join(df_regio)
# 
# # Opschonen
# rm(df_regio)
# 
# #Er is niet goed aangegeven wat missing is in SPSS.
# #tijdelijke functie om 9 Onbekend te verwijderen & naar NA te zetten
# 
# for(var in names(df)){
#   
#   df <- df %>% verwijder_9_onbekend(var)
# 
# }
# 
# # Regionale data filteren
# df %>%
#   filter(GGDregio == regiocode)
# 
# # Gemeentelijke data filteren
# df %>%
#   filter(Gemeentecode == params$gemeentecode)

```

# Uitleg grafiekfuncties en argumenten

In dit document worden de verschillende grafiekfuncties uitgelegd en hoe hier aanpassingen in gedaan kunnen worden.\
\

::: callout-tip
In dit document wordt gebruikt gemaakt van de 'pipe-operator' *%\>%*.

De pipe-operator stuurt een resultaat door naar de volgende functie. Op deze manier kunnen meerdere bewerkingen in R overzichtelijk aan elkaar gekoppeld worden. Lees [hier](#0) een uitleg van de magrittr pipe (en de voordelen).

Zonder de pipe-operator zou het aanroepen van maak_responstabel er zo uit zien:

``` r
maak_responstabel(df = monitor_df, crossings = "gender_2cat", ...)
```

Met pipe-operator

``` r
monitor_df %>% maak_responstabel(crossings = "gender_2cat", ...)
```

Alle functies in dit document hebben als eerste argument 'data', waar een dataframe wordt verwacht. Dit argument zal niet expliciet genoemd worden in de uitleg, omdat het altijd nodig is.
:::

# Responstabel

De functie **maak_responstabel()** maakt een responstabel met het totaal aantal respondenten & deze respondenten uitgesplitst naar kruisvariabelen. Missing waarden op die kruisvariabelen worden standaard weergeven als 'Onbekend'

## Nodige argumenten:

-   **crossings:**\
    Een character vector met kruisvariabelen waarover je N ingevulde vragenlijsten over wilt opsplitsen. Kan 1 of meer zijn.

## Optionele argumenten:

-   **missing_label:**\
    Een character variabele met een alternatief label voor missing waarden (standaard 'Onbekend').

-   **kleuren:\
    **Een named character vector met alternatieve kleuren voor de tabel

### Standaard responstabel met twee crossings

```{r}
#Standaard responstabel met twee crossings:
monitor_df %>% maak_responstabel(
  crossings = c("AGGSA402","AGLFA401"))
```

### Aangepaste responstabel met drie crossings

```{r}
#Responstabel met drie crossings, aangepast missing_label en aangepaste kleuren.
monitor_df %>% maak_responstabel( 
  crossings = c("AGGSA402","AGLFA401","AGOWS404"),
  missing_label = "Niet ingevuld",
  kleuren = c(header =  "#FEC805",
              kleur_1 = "#1A2C54",
              kleur_2 = "#009BD9",
              kleur_tekst = "#FFFFFF"
              )
  )
```

# Grafieken

Hieronder volgt uitleg voor de grafiekfuncties. De functies genereren automatisch alt-text, maar deze kan ook handmatig ingevoerd worden.

::: callout-caution
Als je in Quarto zelf nieuwe blokjes code maakt met grafieken is het belangrijk dat alt-text goed wordt meegenomen bij het renderen van het document. Hier zijn 2 dingen voor nodig:

-   De grafiek moet opgeslagen worden in een object (hieronder 'plot')

-   De alt-text moet opgehaald worden uit het object d.m.v. get_alt_text() en ingevuld worden het argument fig.alt in de 'chunk-options' van het codeblock.

Dit is bij de standaardrapportage uiteraard al geregeld en ziet er dan zo uit:

```{r, echo = T, eval = F}

{r, fig.alt = ggplot2::get_alt_text(plot)}
plot = maak_staafdiagram(...)

plot
```
:::

## Staafdiagram: Dubbele uitsplitsing

De functie **maak_staafdiagram_dubbele_uitsplitsing()** maakt een staafdiagram voor een **dichotome variabele** waarbij de percentages 'ja' (1) worden weergeven. Er kunnen twee kruisvariabelen ingevoerd worden. De eerste kruisvariabele splitst de data op de X-as en de tweede kruisvariabele op kleur.

### Nodige argumenten:

-   **var_inhoud:** Een character met de naam van een dichotome variabele

-   **var_crossing_groep:** Een character met de naam van een kruisvariabele

-   **var_crossing_kleur:** Een character met de naam van een kruisvariabele

### Optionele argumenten: {#optionele-argumenten-1}

-   **titel:** Een character met een titel voor het plot

-   **kleuren:** Een character vector met alternatieve kleuren voor de grafiek

-   **alt_text:** Een character met de 'alt-text' voor de grafiek. Als deze waarde leeg is, wordt er automatisch gegenereerde alt-text meegegeven die alle waarden in de grafiek bevat

-   **nvar:** Een numeric met het minimum aantal observaties per vraag. Als deze waarde leeg is, wordt de standaardwaarde voor nvar aangehouden.

-   **ncel:** Een numeric met het minimum aantal observaties per antwoord. Als deze waarde leeg is, wordt de standaardwaarde voor ncel aangehouden.

### Standaard staafdiagram met dubbele uitsplitsing

```{r, fig.alt= ggplot2::get_alt_text(plot)}

#Standaard staafdiagram met dubbele uitsplitsing
plot = monitor_df %>% 
  maak_staafdiagram_dubbele_uitsplitsing(
    var_inhoud = "LVEES404",
    var_crossing_groep = "AGGSA402",
    var_crossing_kleur = "AGLFA401"
  )

plot

```

### Aangepast staafdiagram met dubbele uitsplitsing

```{r, fig.alt= ggplot2::get_alt_text(plot)}
#Staafdiagram met dubbele uitsplitsing, eigen titel, kleuren, alt-text, nvar en ncel
plot = monitor_df %>% 
  maak_staafdiagram_dubbele_uitsplitsing(
    var_inhoud = "LVEES404",
    var_crossing_groep = "AGGSA402",
    var_crossing_kleur = "AGLFA401",
    titel = "Titel staafdiagram",
    kleuren = c("#FEC805","#1A2C54","#009BD9"),
    alt_text = "Tekst die de grafiek toelicht t.b.v. digitoegankelijkheid",
    nvar = 100,
    ncel = 75
  )

plot
```

## Staafdiagram vergelijking

De functie **maak_staafdiagram_vergelijking()** maakt een staafdiagram voor een **dichotome variabele** waarbij er meerdere kruisvariabelen ingevoerd kunnen worden. De percentages 'ja' (1) worden voor iedere individuele kruisvariabele naast elkaar weergeven.

### Nodige argumenten:

-   **var_inhoud:** Een character met de naam van een dichotome variabele

-   **var_crossings:** Een character vector met de naam van één of meer kruisvariabelen

### Optionele argumenten:

Dezelfde optionele argumenten als in [**maak_staafdiagram_dubbele_uitsplitsing():**](#optionele-argumenten-1):

### Standaard staafdiagram met vergelijking

```{r, fig.alt = ggplot2::get_alt_text(plot)}
#Standaard staafdiagram met vergelijking
plot = monitor_df %>% 
  maak_staafdiagram_vergelijking(
    var_inhoud = "LVEES404",
    var_crossings = c("AGGSA402","AGLFA401")
    )

plot

```

## Staafdiagram met meerdere staven

De functie **maak_staafdiagram_meerdere_staven()** maakt een staafdiagram voor ieder soort variabele waarbij de percentages per antwoord worden weergeven. Optioneel kan een kruisvariabele ingevoerd worden, de grafiek zal de percentages dan opsplitsen op kleur. De grafiek kan ook horizontaal weergeven worden.

### Nodige argumenten:

-   **var_inhoud:** Een character met de naam van een dichotome variabele

### Optionele argumenten:

Naast dezelfde optionele argumenten als in [**maak_staafdiagram_dubbele_uitsplitsing():**](#optionele-argumenten-1):

-   **var_crossing:** Een character met de naam van één kruisvariabele
-   **flip:** TRUE of FALSE. Als TRUE wordt de grafiek horizontaal weergeven

### Standaard staafdiagram met meerdere staven

```{r, fig.alt = ggplot2::get_alt_text(plot)}
#Standaard staafdiagram met meerdere staven
plot = monitor_df %>% 
  maak_staafdiagram_meerdere_staven(
    var_inhoud = "LVVTA404"
    )

plot
```

### Aangepast staafdiagram met meerdere staven

```{r, fig.alt = ggplot2::get_alt_text(plot)}
#Staafdiagram met meerdere staven, kruisvariabele en flip = TRUE
plot = monitor_df %>% 
  maak_staafdiagram_meerdere_staven(
    var_inhoud = "LVVTA404",
    var_crossing = "AGGSA402",
    flip = TRUE
    
  )

plot
```

## Staafdiagram uitsplitsing naast elkaar

De functie **maak_staafdiagram_uitsplitsing_naast_elkaar()** maakt een staafdiagram voor **dichotome variabelen** waarbij de percentages 'ja' (1) voor meerdere kruisvariabelen per uitsplitsing worden weergeven. Optioneel worden de onderscheiden op kleur. De grafiek kan ook horizontaal weergeven worden.

### Nodige argumenten:

-   **var_inhoud:** Een character met de naam van een dichotome variabele
-   **var_crossings:** Een character vector met de naam van één of meer kruisvariabelen

### Optionele argumenten:

Naast dezelfde optionele argumenten als in [**maak_staafdiagram_dubbele_uitsplitsing():**](#optionele-argumenten-1):

-   **kleuren_per_crossing:** TRUE of FALSE. Als TRUE krijgt iedere kruisvariabele een eigen kleur.

-   **fade_kleuren:** TRUE of FALSE. Als TRUE is er overloop in de kleuren per uitsplitsing

-   **flip:** TRUE of FALSE. Als TRUE wordt de grafiek horizontaal weergeven

### Standaard staafdiagram met uitsplitsingen naast elkaar

```{r, fig.alt = ggplot2::get_alt_text(plot)}
#Standaard staafdiagram met uitsplitsingen naast elkaar
plot = monitor_df %>% 
  maak_staafdiagram_uitsplitsing_naast_elkaar(
    var_inhoud = "LVEES404",
    var_crossings = c("AGGSA402","AGLFA401","AGOWS404")
  )

plot
```

### Aangepast staafdiagram met uitsplitsingen naast elkaar

```{r, fig.alt = ggplot2::get_alt_text(plot)}
#Staafdiagram met uitsplitsingen naast elkaar, met overlopende kleuren & horizontaal
plot = monitor_df %>% 
  maak_staafdiagram_uitsplitsing_naast_elkaar(
    var_inhoud = "LVEES404",
    var_crossings = c("AGGSA402","AGLFA401","AGOWS404"),
    kleuren_per_crossing = TRUE,
    fade_kleuren = TRUE,
    flip = TRUE,
    niveaus = "gemeente"
  )

plot
```

## Staafdiagram gestapeld

De functie **maak_staafdiagram_gestapeld()** maakt een horizontaal gestapeld staafdiagram voor ieder soort variabele.

::: callout-tip
figuren die met R worden gemaakt schalen automatisch naar de ruimte die ze hebben. Dit betekend dat het gestapeld staafdiagram standaard 'hoger' is dan gewenst.

De dimensies van een figuur in Quarto kunnen aangepast worden in de chunk-options met de argumenten 'fig.width' en 'fig.height' zoals hier:

```{r, echo = T, eval = F}

{r, fig.alt = ggplot2::get_alt_text(plot), fig.width = 12, fig.height = 3}
plot = maak_staafdiagram(…)

plot
```

\
:::

### Nodige argumenten

-   **var_inhoud:** Een character met de naam van een variabele

### Optionele argumenten

Naast dezelfde optionele argumenten als in [**maak_staafdiagram_dubbele_uitsplitsing():**](#optionele-argumenten-1) - **var_crossing:** Een character met de naam van één kruisvariabele

### Standaard gestapeld staafdiagram

```{r, fig.alt = ggplot2::get_alt_text(plot), fig.width = 12, fig.height = 3}
#Standaard gestapeld staafdiagram
plot = monitor_df %>% 
  maak_staafdiagram_gestapeld(
    var_inhoud = "LVVTA404"
  )

plot
```

### Aangepast gestapeld staafdiagram

```{r, fig.alt = ggplot2::get_alt_text(plot), fig.width = 12, fig.height = 3}
#Standaard gestapeld staafdiagram
plot = monitor_df %>% 
  maak_staafdiagram_gestapeld(
    var_inhoud = "LVVTA404",
    var_crossing = "AGGSA402"
    
  )

plot
```

## Cirkeldiagram

### Nodige argumenten

-   **var_inhoud:** Een character met de naam van een variabele

### Optionele argumenten

-   Dezelfde argumenten als in [**maak_staafdiagram_dubbele_uitsplitsing():**](#optionele-argumenten-1)

-   **titel**: character variabele. Als argument leeg is wordt het variabellabel van var_inhoud gebruikt.

```{r}

#LET OP: ITT tot andere grafiekfuncties moet je géén get_alt_text() gebruiken in de chunk-options. Cirkeldiagrammen worden met plotly gemaakt en de alt-text wordt in door de functie maak_cirkeldiagram() al correct toegevoegd.

#Standaard cirkeldiagram staafdiagram
plot = monitor_df %>% 
  maak_cirkeldiagram(
    var_inhoud = "LVVTA404"
  )

plot
```

## Populatiegrafiek CBS

Functie om een horizontaal georienteerd gestapeld staafdiagram te maken waarin populatiegegevens van het CBS worden vergeleken met de response op de per regio en gemeente. Dit kan o.b.v. de kruisvariabelen leeftijd en geslacht gedaan worden.

::: calout-warning
Hieronder wordt monitor_df_regio gebruikt ITT bovenstaande waar monitor_df wordt gebruikt.

TODO; landelijke demografische cijfers toevoegen aan functie TODO; uitzoeken wel dataframes er allemaal gebruikt zullen worden.
:::

### Optionele argumenten

-   **gem_code:** character variabele met gemeentenaam. Standaard de 'huidige' gemeente o.b.v. params\$gemeentecode.
-   **crossing_cbs:** character variabele. De naam van de kruising die getoond moet worden. Opties: "leeftijd" of "geslacht".
-   **niveaus:** character vector met niveaus die getoond moeten worden. Standaard c("nl","regio","gemeente")
-   **missing_bewaren:** TRUE of FALSE. Als TRUE worden percentages met missing categorieën voor *Deelnemers* bewaard en getoond in de grafiek.
-   **missing_label:** character variabele. Het label dat gegeven moet worden aan een eventuele missing categorie. Standaard "Onbekend".
-   **kleuren:** Een character vector met alternatieve kleuren voor de grafiek

### Standaard Populatiegrafiek CBS

```{r, fig.alt = ggplot2::get_alt_text(plot)}
plot <- monitor_df_regio %>% 
  maak_grafiek_cbs_bevolking()


plot
```

### Aangepaste Populatiegrafiek CBS

```{r}
plot <- monitor_df_regio %>% 
  maak_grafiek_cbs_bevolking(
    niveaus = c("regio","gemeente"),
    crossing_cbs = "geslacht",
    missing_bewaren = TRUE,
    missing_label = "niet ingevuld",

  )

plot
```

# Adaptieve tekst

Hieronder volgen een aantal functies die gebruikt kunnen worden in een tekst.

## Maak percentage

De functie **maak_percentage()** berekent een percentage van een indicator. De functie geeft als output het percentage (getal) met een %-teken als character, bijvoorbeeld 88%.

## Nodige argumenten:

-   **data:**\
    Een dataframe met alle data.
-   **survey_design:**\
    Een survey_design, berekent met svydesign. Dit is noodzakelijk om percentages en confidence intervallen te kunnen berekenen.
-   **variabele:**\
    Een character vector met de naam van de indicator waarvan je het percentage wil berekenen.

## Optionele argumenten:

-   **value:\
    **Een getal dat aangeeft welk value van de de variabele vergeleken wordt. Default is 1.

### Standaard percentage

```{r, warning = F}
# Standaard percentage:
monitor_df %>%
  maak_percentage(survey_design = design_gem, variabele = 'GZGGA402')
```

### Bereken percentage en toon in bol grafiek

```{r, warning = F}
# Percentage in bol grafiek
monitor_df %>%
  maak_percentage(survey_design = design_gem, variabele = 'LVPKS403') %>% # bereken percentage
  bol_met_cijfer() # toon in bol grafiek
```

## Maak tekstuele vergelijking

De functie **maak_vergelijking()** maakt een vergelijking tussen de categorieën van een uitsplitsing voor een bepaalde indicator. Bijvoorbeeld een vergelijking tussen het percentage mannen en vrouwen dat zich gelukkig voelt. Hiervoor berekent de functie het percentage en de confidence intervallen van een indicator en bepaalt vervolgens of er overlap zit tussen deze confidence intervallen. De functie geeft als output een zin waarin aangegeven of de uitsplitsingen al dan niet vergelijkbaar zijn.

## Nodige argumenten:

-   **data:**\
    Een dataframe met alle data.
-   **survey_design:**\
    Een survey_design, berekent met svydesign. Dit is noodzakelijk om percentages en confidence intervallen te kunnen berekenen.
-   **variabele:**\
    Een character vector met de naam van de indicator waarvan je de percentages wil vergelijken.
-   **vergelijking:**\
    Een character vector met de naam van de indicator waarover je wil uitsplitsen. De indicator moet minimaal 2 categorieën en maximaal 3 categorieën bevatten.

## Optionele argumenten:

-   **variabele_label:**\
    Een character variabele met een alternatief label voor de variabele. Default is NULL (automatisch label o.b.v. label van variabele in data).

-   **value:\
    **Een getal dat aangeeft welk value van de de variabele vergeleken wordt. Default is 1.

### Standaard vergelijking tussen mannen en vrouwen

```{r, warning = F}
#Standaard vergelijking tussen mannen en vrouwen:
monitor_df %>% maak_vergelijking(survey_design = design_gem, 
                                 variabele = 'GZGGA402', 
                                 variabele_label = "hun eigen gezondheid als (zeer) goed ervaart",
                                 vergelijking = 'AGGSA401')

# Bij een vergelijking tussen gender of tussen leeftijdscategorieën worden de labels aangepast. Bij gebruik van andere indicatoren worden de labels uit de data gebruikt.
```

### Vergelijking tussen 3 groepen

```{r, warning = F}
# Vergelijking tussen migratieachtergrond in 3 categorieën:
monitor_df %>% maak_vergelijking(survey_design = design_gem, 
                                 variabele = 'GZGGA402', 
                                 variabele_label = "hun eigen gezondheid als (zeer) goed ervaart",
                                 vergelijking = 'AGETS414')

# Bij gebruik van andere indicatoren dan gender en leeftijdscategorieën worden de labels uit de data gebruikt.
```

## Maak top

De functie **maak_top()** sorteert indicatoren van hoogst naar laagst percentage. De functie geeft als output een zin met het label van de indicator en het bijbehorende percentage.

## Nodige argumenten:

-   **data:**\
    Een dataframe met alle data.
-   **survey_design:**\
    Een survey_design, berekent met svydesign. Dit is noodzakelijk om percentages en confidence intervallen te kunnen berekenen.
-   **variabelen:**\
    Een character vector met de na(a)m(en) van de indicator(en) waarvan je de percentages van hoog naar laag wil sorteren.
-   **top:**\
    Een getal dat aangeeft welke percentages van de top je als output wil. Dit kan een getal zijn (bv. 3, dan is de output het op 2-na-hoogste percentage) of een reeks van getallen (bv. 1:5, dan is de output de top 5 van hoogste percentages). Default is 1.

## Optionele argumenten:

-   **toon_label:**\
    Boolean (TRUE of FALSE) die aangeeft of het label van het percentage bij de output gegeven moet worden. TRUE geeft aan dat het label bij de output komt. Default is TRUE.

-   **value:\
    **Een getal dat aangeeft welk value van de de variabele vergeleken wordt. Default is 1.

### Bereken hoogste percentage

```{r, warning = F}
# Top 1 zonder label
monitor_df %>% maak_top(survey_design = design_gem, 
                        variabelen = c("LVVTA404", "LVVTA405", "LVVTA406", "LVVTA407", "LVVTA408", "LVVTA409", "LVVTA410"),
                        toon_label = FALSE, # Wijzig FALSE naar TRUE om label te tonen.
                        top = 1)
```

### Bereken top 3 van meerdere indicatoren

```{r, warning = F}
# Top 3
monitor_df %>% maak_top(survey_design = design_gem, 
                        variabelen = c("LVVTA404", "LVVTA405", "LVVTA406", "LVVTA407", "LVVTA408", "LVVTA409", "LVVTA410"),
                        top = 1:3)
```

### Bereken top 3 binnen indicator

```{r, warning = F}
# Top 3 
monitor_df %>% maak_top(survey_design = design_gem, 
                        variabelen = 'AGLFA401',
                        value = 1:3, # Vul hier alle values in die voorkomen bij indicator
                        top = 1:3)
```
